# 二叉树的处理

## 题目类型



## 相关题目

### 剑指offer [**JZ4** **重建二叉树**](https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&&tqId=11157&rp=1&ru=/ta/coding-interviews&qru=/ta/coding-interviews/question-ranking)

题目描述：根据给出的二叉树的前序遍历 $pre$ 和中序遍历 $vin$ ，重建一颗二叉树

`思路` 递归构建，要非常注意不要忘了「**递归出口**」

```C++
class Solution {
public:
    TreeNode* reConstructBinaryTree(vector<int> pre,vector<int> vin) {
        // 0 开始忘了写这一句，导致段错误，递归没有出口
        if(vin.size() == 0 || pre.size() == 0) return NULL;
        
        // 1 前序遍历的第一个值是树的根节点
        int rootVal = pre[0];
        TreeNode* root = new TreeNode(rootVal);
        
        // 2 在中序遍历中找到根节点的索引，根据索引计算左右子树的大小
        int leftSize = 0;
        for(int i = 0; i < vin.size(); i++){
            if(vin[i] == rootVal){
                leftSize = i;
                break;
            }
        }
        
        // 3 保存左、右子树的前序和中序遍历值
        vector<int> pre_left, pre_right, vin_left, vin_right;
        for(int i = 0; i < leftSize; i++){
            pre_left.push_back(pre[i + 1]);
            vin_left.push_back(vin[i]);
        }
        for(int i = leftSize + 1; i < vin.size(); i++){
            pre_right.push_back(pre[i]);
            vin_right.push_back(vin[i]);
        }
        
        // 4 递归的构建左右子树,并连接到根节点上
        root->left = reConstructBinaryTree(pre_left, vin_left);
        root->right = reConstructBinaryTree(pre_right, vin_right);
        
        
        return root;
    }
};
```

