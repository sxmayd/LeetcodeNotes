# 					回溯算法

## 回溯算法的术语

`路径` 已经做出的选择

`选择列表` 当前可以做的选择

`结束条件` 到达了决策树的底层，无法再做选择的条件

## 回溯算法代码框架

```c++
void backtrack(路径, 选择列表){
    if 满足结束条件:
        result.add(路径)
        return;
    
    for 选择 in 选择列表:
        做选择
        backtrack(路径, 选择列表)
        撤销选择
}
```

根据下述递归代码框架，`for`循环里面`做选择`属于前序遍历，而`撤销选择`属于后序遍历；之所以这样安排的原因可见下图所示

```c++
void traverse(TreeNode* root) {
    for (TreeNode* child : root->childern)
        // 前序遍历需要的操作
        traverse(child);
        // 后序遍历需要的操作
}
```

![img](https://labuladong.gitee.io/algo/images/backtracking/4.jpg)

## 我的理解

1. 回溯算法本质上是`DFS`的一种应用
2. 利用回溯算法解题时，往往分为两个函数，一个是`backtrack()`函数，用于解决回溯本身,而且这个函数通常返回值是*void*；另一个是主函数，用以解决问题本身
3. 

## Leetcode相关题目

- Leetcode 46 “全排列”

题目描述：给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列**。

```c++
class Solution {
public:
    vector<vector<int>> res;

    void backtrack(vector<int> nums, vector<int> track, vector<bool> used){
        // 结束条件
        if(track.size() == nums.size()){
            res.push_back(track);
            return;
        }

        for(int i = 0; i < nums.size(); i++){
            // 排除不合法的选择
            if(used[i] == true) continue;
            // 前序遍历，做选择
            track.push_back(nums[i]);
            used[i] = true;
            // 递归，进入下一层决策树
            backtrack(nums, track, used);
            // 后序遍历，取消选择
            track.pop_back();
            used[i] = false;
        }
    }

    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(), false);
        vector<int> track;
        backtrack(nums, track, used);
        return res;
    }
};
```

- N皇后问题

题目描述：将 `n` 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 n ，返回所有不同的 n 皇后问题 的解决方案，方案中 'Q' 和 '.' 分别代表了皇后和空位。

`注` 不能相互攻击指的是皇后的行、列、对角线、斜对角线上没有皇后，如下图所示：

<img src="C:\Users\sxmayd\AppData\Roaming\Typora\typora-user-images\image-20210720230757814.png" alt="image-20210720230757814" style="zoom: 25%;" />

```c++
class Solution {
public:
    vector<vector<string>> res;

    void backtrack(vector<string>& board, int row){
        //结束条件
        if(row == board.size()){
            res.push_back(board); //放入皇后结束，将这一幅棋盘存入结果中
            return;
        }

        int n = board.size();
        for(int col = 0; col < n; col++){
            // 排除不合法的情况
            if(!isVaild(board, row, col)) continue;
            // 做选择
            board[row][col] = 'Q';
            // 进入下一层决策
            backtrack(board, row + 1);
            // 撤销选择
            board[row][col] = '.';
        }
    }
    /* 主函数， 返回n皇后问题的结果 */
    vector<vector<string>> solveNQueens(int n) {
        //初始化棋盘
        vector<string> board(n, string(n, '.')); //二维动态数组初始化
        backtrack(board, 0); // 从第0行开始
        return res;
    }

    /* 判断是否可以在 board[row][col] 放置皇后 */
    bool isVaild(vector<string> board, int row, int col){
        int n = board.size();
        /* 只需要检查当前行上方的元素 */
        // 1. 当前列
        for(int i = 0; i < row; i++){
            if(board[i][col] == 'Q') return false;
        }
        // 1. 左上方
        for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){
            if(board[i][j] == 'Q') return false;
        }
        // 1. 右上方
        for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
            if(board[i][j] == 'Q') return false;
        }

        return true;
    }
};
```

